import{_ as d,c as e,o as r,ah as o}from"./chunks/framework.DGOuNAW6.js";const g=JSON.parse('{"title":"SECS GEM","description":"","frontmatter":{},"headers":[],"relativePath":"zh_CN/configuration/south-devices/secs-gem/secs-gem.md","filePath":"zh_CN/configuration/south-devices/secs-gem/secs-gem.md"}'),a={name:"zh_CN/configuration/south-devices/secs-gem/secs-gem.md"};function l(i,t,n,c,s,S){return r(),e("div",null,[...t[0]||(t[0]=[o('<h1 id="secs-gem" tabindex="-1">SECS GEM <a class="header-anchor" href="#secs-gem" aria-label="Permalink to “SECS GEM”">​</a></h1><p>SECS GEM HSMS 驱动通过 TCP/IP 协议访问支持 SEMI E37 HSMS 标准的设备，目前支持设备 PASSIVE 模式，驱动作为 Host 主动连接。</p><h2 id="设备设置" tabindex="-1">设备设置 <a class="header-anchor" href="#设备设置" aria-label="Permalink to “设备设置”">​</a></h2><table tabindex="0"><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>host</td><td>设备 IP 地址</td></tr><tr><td>port</td><td>设备端口号, 默认5000</td></tr><tr><td>deviceid</td><td>设备 ID, 默认0</td></tr></tbody></table><h2 id="支持的数据类型" tabindex="-1">支持的数据类型 <a class="header-anchor" href="#支持的数据类型" aria-label="Permalink to “支持的数据类型”">​</a></h2><ul><li>uint8</li><li>int8</li><li>uint16</li><li>int16</li><li>uint32</li><li>int32</li><li>uint64</li><li>int64</li><li>float</li><li>double</li><li>bool</li><li>string</li><li>bytes</li></ul><h2 id="地址格式" tabindex="-1">地址格式 <a class="header-anchor" href="#地址格式" aria-label="Permalink to “地址格式”">​</a></h2><blockquote><p>SxFy([_1][_2][_3][_4])</p></blockquote><h2 id="streams-和-functions" tabindex="-1">Streams 和 Functions <a class="header-anchor" href="#streams-和-functions" aria-label="Permalink to “Streams 和 Functions”">​</a></h2><p>SECS-II 消息称为流和功能。每条消息都有一个流值（ Sx ）和一个功能值（ Fy ）。对于流1功能1，它写为 S1F1，读为 “S1F1” 。流是消息的类别，而功能是类别中的特定消息。主消息中的功能值始终是奇数，关联的二次答复中的功能值始终比主消息中的功能值大1或偶数。</p><table tabindex="0"><thead><tr><th>Stream</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>设备状态</td></tr><tr><td>2</td><td>设备控制</td></tr><tr><td>3</td><td>材料状态</td></tr><tr><td>4</td><td>材料控制</td></tr><tr><td>5</td><td>报警处理</td></tr><tr><td>6</td><td>数据收集</td></tr><tr><td>7</td><td>配方管理</td></tr><tr><td>8</td><td>控制程序传输</td></tr><tr><td>9</td><td>系统错误</td></tr><tr><td>10</td><td>终端服务</td></tr><tr><td>11</td><td>未启用</td></tr><tr><td>12</td><td>晶片图形布置</td></tr><tr><td>13</td><td>未格式化的数据集传输</td></tr></tbody></table><p><strong>常用 SxFy</strong></p><table tabindex="0"><thead><tr><th>Stream Function</th><th>说明</th></tr></thead><tbody><tr><td>S1F1</td><td>Hello消息</td></tr><tr><td>S1F2</td><td>在线数据</td></tr><tr><td>S1F3</td><td>选定设备状态数据</td></tr><tr><td>S1F4</td><td>格式化的设备状态数据</td></tr><tr><td>S6F7</td><td>数据传输请求</td></tr><tr><td>S6F8</td><td>数据传输数据</td></tr><tr><td>S6F15</td><td>事件报告请求</td></tr><tr><td>S6F16</td><td>事件报告数据</td></tr></tbody></table><h2 id="特殊类型处理" tabindex="-1">特殊类型处理 <a class="header-anchor" href="#特殊类型处理" aria-label="Permalink to “特殊类型处理”">​</a></h2><p>SECS-II 消息定义了 LIST 类型，插件也通过 string 支持该类型，但是有一个反序列化的过程，具体的规则如下所示。</p><table tabindex="0"><thead><tr><th>SECS-II 类型</th><th>序列化</th><th>说明</th></tr></thead><tbody><tr><td>LIST</td><td><code>&lt;L[n] xxx&gt;(.)</code></td><td>n 为 LIST 长度，空 LIST n 为 0， 最外层 LIST 最后包括 <em>.</em></td></tr><tr><td>ASCII</td><td><code>&lt;A[n] xxx&gt; </code></td><td>n 为 ASCII 长度，空 ASCII n 为 0</td></tr><tr><td>Binary</td><td><code>&lt;B[n] xxx&gt; </code></td><td>n 为 BInary 长度，空 BInary n 为 0</td></tr><tr><td>Boolean</td><td><code>&lt;Boolean x&gt; </code></td><td></td></tr><tr><td>UINT8</td><td><code>&lt;U1 x&gt; </code></td><td></td></tr><tr><td>UINT16</td><td><code>&lt;U2 x&gt; </code></td><td></td></tr><tr><td>UINT32</td><td><code>&lt;U4 x&gt; </code></td><td></td></tr><tr><td>UINT64</td><td><code>&lt;U8 x&gt; </code></td><td></td></tr><tr><td>INT8</td><td><code>&lt;I1 x&gt; </code></td><td></td></tr><tr><td>INT16</td><td><code>&lt;I2 x&gt; </code></td><td></td></tr><tr><td>INT32</td><td><code>&lt;I4 x&gt; </code></td><td></td></tr><tr><td>INT64</td><td><code>&lt;I8 x&gt; </code></td><td></td></tr><tr><td>32FLOAT</td><td><code>&lt;F4 x&gt; </code></td><td></td></tr><tr><td>64FLOAT</td><td><code>&lt;F8 x&gt; </code></td><td></td></tr></tbody></table><p>LIST 类型支持使用下标访问具体的元素，目前支持嵌套四层 LIST。</p><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to “常见问题”">​</a></h2><ul><li><p>设备 ID 如何填写？ 设备 ID 一般在设备的 SECS GEM HSMS 协议配置页面可以查看。</p></li><li><p>LIST 中 ASCII 类型如何序列化？ 本插件 LIST 中 ASCII 序列化为 <code>&lt;A[n] xxx&gt;</code>，内容不带引号。例如 &quot;ABC&quot; 序列化为 <code>&lt;A[3] ABC&gt;</code>，而不是 <code>&lt;A[3] &quot;ABC&quot;&gt;</code>。</p></li><li><p>LIST 中 Binary 类型如何序列化？ 本插件 LIST 中 Binary 序列化为 <code>&lt;B[n] xx&gt;</code>，内容不带引号。例如 0xFF 序列化为 <code>&lt;B[1] FF&gt;</code>，而不是 <code>&lt;B[2] &quot;FF&quot;&gt;</code>。</p></li><li><p>LIST 类型数据新建点位的时候应该选择什么类型？ 设备数据类型为 <strong>LIST</strong> 的点位，在新建的时候选择 <strong>string</strong> 类型。</p></li><li><p>设备主动上报的事件如何新建点位？ 对于例如 <code>S6F11</code> 等设备主动上报的点位，直接新建相应的点位即可。</p></li><li><p>对于需要传递参数进行数据获取的点位如何新建点位？ 例如 <code>S1F3</code>，需要携带 <strong>LIST</strong> 类型的参数，其返回值会通过 <code>S1F4</code> 返回，类型也为 <strong>LIST</strong>。那么对于这个点位，我们需要新建两个点位，一个地址为 <code>S1F3</code>，属性配置 <strong>Write</strong>，类型为 <strong>string</strong>。另一个地址为 <code>S1F4</code>，属性配置为 <strong>Read</strong> 或者 <strong>Sub</strong>，类型为 <strong>string</strong>。使用第一个点位写入参数，第二个节点获取返回值。</p></li><li><p>对于不需要传递参数进行数据获取的点位如何新建点位？ 例如 <code>S1F1</code>，其不需要传递参数，那么只需要新建一个点位即可，其返回值会直接在此点位显示。</p></li></ul>',19)])])}const I=d(a,[["render",l]]);export{g as __pageData,I as default};
