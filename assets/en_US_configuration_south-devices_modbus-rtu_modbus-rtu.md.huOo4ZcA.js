import{_ as e,c as r,o as d,ah as a}from"./chunks/framework.DGOuNAW6.js";const u=JSON.parse('{"title":"Modbus RTU","description":"","frontmatter":{},"headers":[],"relativePath":"en_US/configuration/south-devices/modbus-rtu/modbus-rtu.md","filePath":"en_US/configuration/south-devices/modbus-rtu/modbus-rtu.md"}'),o={name:"en_US/configuration/south-devices/modbus-rtu/modbus-rtu.md"};function i(s,t,n,l,h,c){return d(),r("div",null,[...t[0]||(t[0]=[a('<h1 id="modbus-rtu" tabindex="-1">Modbus RTU <a class="header-anchor" href="#modbus-rtu" aria-label="Permalink to “Modbus RTU”">​</a></h1><p>Modbus RTU is a version of the Modbus protocol that is based on serial communication. Unlike the Modbus TCP protocol, Modbus RTU is typically used to connect sensors, actuators, and other control devices on a factory production line. It is a fast, reliable, and flexible serial communication protocol that provides reliable data transmission and control functions.</p><p>The Modbus RTU protocol uses binary encoding and can transmit data over RS-232, RS-485, or other serial communication media. GridBeat Modbus RTU plugin adds an implementation based on Ethernet TCP and enables remote device data acquisition and control through a DTU device.</p><h2 id="add-device" tabindex="-1">Add Device <a class="header-anchor" href="#add-device" aria-label="Permalink to “Add Device”">​</a></h2><p>Go to <strong>Configuration -&gt; South Devices</strong>, then click <strong>Add Device</strong> to add the driver. Configure the following settings in the popup dialog box.</p><ul><li>Name: The name of this device node.</li><li>Plugin: Select the <strong>Modbus RTU</strong> plugin.</li></ul><h2 id="device-configuration" tabindex="-1">Device Configuration <a class="header-anchor" href="#device-configuration" aria-label="Permalink to “Device Configuration”">​</a></h2><p>After clicking <strong>Create</strong>, you will be redirected to the <strong>Device Configuration</strong> page, where we will set up the parameters required for GridBeat to establish a connection with the device. You can also click the device configuration icon on the southbound device card to enter the <strong>Device Configuration</strong> interface.</p><table tabindex="0"><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><strong>Physical Link</strong></td><td>Selects the communication medium, either serial or Ethernet.</td></tr><tr><td><strong>Connection Timeout</strong></td><td>The time the system waits for a device to respond to a command.</td></tr><tr><td><strong>Maximum Retry Times</strong></td><td>The maximum number of retries after a failed attempt to send a read command.</td></tr><tr><td><strong>Retry Interval</strong></td><td>Resend reading instruction interval(ms) after a failed attempt to send a read command.</td></tr><tr><td><strong>Send Interval</strong></td><td>The waiting time between sending each read/write command. Some serial devices may discard certain commands if they receive consecutive commands in a short period of time.</td></tr><tr><td><strong>4-byte Endianness</strong></td><td>Byte order of tags with 32 bits, ABCD corresponds to 1234.</td></tr><tr><td><strong>8-byte Endianness</strong></td><td>Byte order of tags with 64 bits, with each number representing one byte.</td></tr><tr><td><strong>Start Address</strong></td><td>Address starts from 1 or 0.</td></tr><tr><td><strong>Serial Device</strong></td><td>Only needed in <strong>Serial</strong> mode, the path to the serial device when using a serial connection, e.g., /dev/ttyS0 in Linux systems.</td></tr><tr><td><strong>Stop Bits</strong></td><td>Only for the <strong>Serial</strong> mode, the serial connection parameter.</td></tr><tr><td><strong>Parity</strong></td><td>Only for the <strong>Serial</strong> mode, the serial connection parameter.</td></tr><tr><td><strong>Baud Rate</strong></td><td>Only for the <strong>Serial</strong> mode, the serial connection parameter.</td></tr><tr><td><strong>Data Bits</strong></td><td>Only for the <strong>Serial</strong> mode, the serial connection parameter.</td></tr><tr><td><strong>Connection Mode</strong></td><td>Only for the <strong>Ethernet</strong> mode, you can choose GridBeat as the TCP client or server.</td></tr><tr><td><strong>IP Address</strong></td><td>Only for the <strong>Ethernet</strong> mode, the IP address of the device when using TCP connection with GridBeat as the client, or the IP address of GridBeat when using TCP connection with GridBeat as the server. The default value is 0.0.0.0.</td></tr><tr><td><strong>Port</strong></td><td>Only for the <strong>Ethernet</strong> mode, the port number of the device when using TCP connection with GridBeat as the client, or the port number of GridBeat when using TCP connection with GridBeat as the server.</td></tr><tr><td><strong>Device Degradation</strong></td><td>Enable or disable device degradation mechanism.</td></tr><tr><td><strong>Failure Threshold for Degradation</strong></td><td>The number of consecutive failure cycles required to trigger device degradation.</td></tr><tr><td><strong>Recovery Time After Degradation</strong></td><td>The time in seconds after which the device recovers from degradation.</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>The above configuration can meet the individualized needs of the device:<br></p><ol><li>Retry requests are considered as the same request, i.e., a successful retry is regarded as a successful request.<br></li><li>In the same read cycle, if a certain tag under a slave id does not receive a response, requests for other tags under the same slave id in that cycle will be skipped.<br></li><li>The device degradation is triggered when a certain tag under a slave id fails to respond for multiple consecutive cycles (or can be configured to trigger after just one failed cycle). Once triggered, all requests for that slave will be stopped for the configured period.</li></ol></div><h2 id="configure-data-groups-and-tags" tabindex="-1">Configure Data Groups and Tags <a class="header-anchor" href="#configure-data-groups-and-tags" aria-label="Permalink to “Configure Data Groups and Tags”">​</a></h2><p>After the plugin is added and configured, the next step is to establish communication between your device and GridBeat by adding groups and tags to the Southbound driver.</p><p>Once device configuration is completed, navigate to the <strong>South Devices</strong> page. Click on the device card or device row to access the <strong>Group List</strong> page. Here, you can create a new group by clicking on <strong>Create</strong>, then specifying the group name and data collection interval.</p><p>Upon successfully creating a group, click on its name to proceed to the <strong>Tag List</strong> page. This page allows you to add device tags for data collection. You&#39;ll need to provide information such as the tag address, attributes, and data type.</p><p>For information on general configuration items, see <a href="./../south-devices.html">Connect to Southbound Devices</a>. The subsequent section will concentrate on configurations specific to the driver.</p><h3 id="data-types" tabindex="-1">Data Types <a class="header-anchor" href="#data-types" aria-label="Permalink to “Data Types”">​</a></h3><ul><li>INT16</li><li>UINT16</li><li>INT32</li><li>UINT32</li><li>INT64</li><li>UINT64</li><li>FLOAT</li><li>DOUBLE</li><li>BIT</li><li>STRING</li><li>BYTES</li></ul><h3 id="address-format" tabindex="-1">Address Format <a class="header-anchor" href="#address-format" aria-label="Permalink to “Address Format”">​</a></h3><blockquote><p>SLAVE!ADDRESS[.BIT][#ENDIAN][.LEN[H][L][D][E]][.BYTES]</p></blockquote><h4 id="slave" tabindex="-1"><strong>SLAVE</strong> <a class="header-anchor" href="#slave" aria-label="Permalink to “SLAVE”">​</a></h4><p>Required, Slave is the slave address or site number.</p><h4 id="address" tabindex="-1"><strong>ADDRESS</strong> <a class="header-anchor" href="#address" aria-label="Permalink to “ADDRESS”">​</a></h4><p>Required, Address is the register address. The Modbus protocol has four areas, each area has a maximum of 65536 registers, and the address range of each area is shown in the table below. It should be noted that a storage area as large as 65536 is generally not required in practical applications. Generally, PLC manufacturers generally use an address range within 10000. Please pay attention to fill in the correct point address according to the area and function code of the device.</p><table tabindex="0"><thead><tr><th>Area</th><th>Address Range</th><th>Attribute</th><th>Register Size</th><th>Function Code</th><th>Data Type</th></tr></thead><tbody><tr><td>Coil</td><td>000001 ~ 065536</td><td>Read/Write</td><td>1Bit</td><td>0x01, 0x05, 0x0f</td><td>BIT</td></tr><tr><td>Input</td><td>100001 ~ 165536</td><td>Read/Write</td><td>1Bit</td><td>0x02</td><td>BIT</td></tr><tr><td>Input Register</td><td>300001 ~ 365536</td><td>Read/Write</td><td>16Bit,2Byte</td><td>0x04</td><td>BIT, INT16, UINT16,<br>INT32, UINT32,<br>INT64, UINT64,<br>FLOAT, DOUBLE, STRING</td></tr><tr><td>Hold Register</td><td>400001 ~ 465536</td><td>Read/Write</td><td>16Bit,2Byte</td><td>0x03, 0x06, 0x10</td><td>BIT, INT16, UINT16,<br>INT32, UINT32, INT64,<br>UINT64, FLOAT, DOUBLE,<br>STRING</td></tr></tbody></table><h4 id="bit" tabindex="-1"><strong>.BIT</strong> <a class="header-anchor" href="#bit" aria-label="Permalink to “.BIT”">​</a></h4><p>Optional, specify a specific bit in a register.</p><table tabindex="0"><thead><tr><th>Address</th><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td>1!300004.0</td><td>bit</td><td>Refers to station 1, input register area, address 300004, bit 0</td></tr><tr><td>1!400010.4</td><td>bit</td><td>Refers to station 1, hold register area, address 400010, bit 4</td></tr><tr><td>2!400001.15</td><td>bit</td><td>Refers to station 2, hold register area, address 400001, bit 15</td></tr></tbody></table><h4 id="endian" tabindex="-1"><strong>#ENDIAN</strong> <a class="header-anchor" href="#endian" aria-label="Permalink to “#ENDIAN”">​</a></h4><p>Optional, byte order, applicable to data types int16/uint16/int32/uint32/float, see the table below for details.</p><table tabindex="0"><thead><tr><th>Symbol</th><th>Byte Order</th><th>Supported Data Types</th><th>Note</th></tr></thead><tbody><tr><td>#B</td><td>2,1</td><td>int16/uint16</td><td></td></tr><tr><td>#L</td><td>1,2</td><td>int16/uint16</td><td>Default byte order if not specified</td></tr><tr><td>#LL</td><td>1,2,3,4</td><td>int32/uint32/float</td><td>Default byte order if not specified</td></tr><tr><td>#LB</td><td>2,1,4,3</td><td>int32/uint32/float</td><td></td></tr><tr><td>#BL</td><td>3,4,1,2</td><td>int32/uint32/float</td><td></td></tr><tr><td>#BB</td><td>4,3,2,1</td><td>int32/uint32/float</td><td></td></tr></tbody></table><p>Byte order also applies to int64/uint64/double data types. Each digit represents one byte. See the following table for detailed information.</p><table tabindex="0"><thead><tr><th>Symbol</th><th>Byte Order</th><th>Supported Data Types</th><th>Note</th></tr></thead><tbody><tr><td>#LL</td><td>12,34,56,78</td><td>int64/uint64/double</td><td>Default byte order if not specified</td></tr><tr><td>#LB</td><td>21,43,65,87</td><td>int64/uint64/double</td><td></td></tr><tr><td>#BL</td><td>78,56,34,12</td><td>int64/uint64/double</td><td></td></tr><tr><td>#BB</td><td>87,65,43,21</td><td>int64/uint64/double</td><td></td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>The byte order of a tag has a higher priority than the byte order configuration of a node. That is to say, once the byte order is configured for a tag, it follows the configuration of that tag and ignores the node configuration. The byte order can be illustrated using the notation ABCD, which corresponds directly to the sequence 1234. As an example, the ABCD designation represents the standard or default Endianness 1234. (#LL).</p></div><h4 id="len-h-l-d-e" tabindex="-1">.LEN[H][L][D][E] <a class="header-anchor" href="#len-h-l-d-e" aria-label="Permalink to “.LEN[H][L][D][E]”">​</a></h4><p>When the data type is STRING, <code>.LEN</code> is a required field, indicating the number of bytes the string occupies. Each register contains four storage methods: H, L, D, and E, as shown in the table below.</p><table tabindex="0"><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td>H</td><td>One register stores two bytes, with the high byte first</td></tr><tr><td>L</td><td>One register stores two bytes, with the low byte first</td></tr><tr><td>D</td><td>One register stores one byte, and it is stored in the low byte</td></tr><tr><td>E</td><td>One register stores one byte, and it is stored in the high byte</td></tr></tbody></table><h4 id="bytes" tabindex="-1"><strong>.BYTES</strong> <a class="header-anchor" href="#bytes" aria-label="Permalink to “.BYTES”">​</a></h4><p>Optional, read and write the length of bytes type data, applicable to bytes data type.</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>A register of the Modbus driver contains 2 bytes. When reading and writing Modbus register data in the bytes data type, please ensure that the bytes parameter is set to an even number.</p></div><h3 id="example-addresses" tabindex="-1">Example Addresses <a class="header-anchor" href="#example-addresses" aria-label="Permalink to “Example Addresses”">​</a></h3><table tabindex="0"><thead><tr><th>Address</th><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td>1!300004</td><td>int16</td><td>Refers to station 1, input register area, address 300004, byte order #L</td></tr><tr><td>1!300004#B</td><td>int16</td><td>Refers to station 1, input register area, address 300004, byte order #B</td></tr><tr><td>1!300004#L</td><td>uint16</td><td>Refers to station 1, input register area, address 300004, byte order #L</td></tr><tr><td>1!400004</td><td>int16</td><td>Refers to station 1, hold register area, address 400004, byte order #L</td></tr><tr><td>1!400004#L</td><td>int16</td><td>Refers to station 1, hold register area, address 400004, byte order #L</td></tr><tr><td>1!400004#B</td><td>uint16</td><td>Refers to station 1, hold register area, address 400004, byte order #B</td></tr><tr><td>1!300004</td><td>int32</td><td>Refers to station 1, input register area, address 300004, byte order #LL</td></tr><tr><td>1!300004#BB</td><td>uint32</td><td>Refers to station 1, input register area, address 300004, byte order #BB</td></tr><tr><td>1!300004#LB</td><td>uint32</td><td>Refers to station 1, input register area, address 300004, byte order #LB</td></tr><tr><td>1!300004#BL</td><td>float</td><td>Refers to station 1, input register area, address 300004, byte order #BL</td></tr><tr><td>1!300004#LL</td><td>int32</td><td>Refers to station 1, input register area, address 300004, byte order #LL</td></tr><tr><td>1!400004</td><td>int32</td><td>Refers to station 1, hold register area, address 400004, byte order #LL</td></tr><tr><td>1!400004#LB</td><td>uint32</td><td>Refers to station 1, hold register area, address 400004, byte order #LB</td></tr><tr><td>1!400004#BB</td><td>uint32</td><td>Refers to station 1, hold register area, address 400004, byte order #BB</td></tr><tr><td>1!400004#LL</td><td>int32</td><td>Refers to station 1, hold register area, address 400004, byte order #LL</td></tr><tr><td>1!400004#BL</td><td>float</td><td>Refers to station 1, hold register area, address 400004, byte order #BL</td></tr><tr><td>1!300001.10</td><td>String</td><td>Refers to station 1, input register area, address 300001, character length 10, byte order L, which occupies addresses 300001 to 300005</td></tr><tr><td>1!300001.10H</td><td>String</td><td>Refers to station 1, input register area, address 300001, character length 10, byte order H, which occupies addresses 300001 to 300005</td></tr><tr><td>1!300001.10L</td><td>String</td><td>Refers to station 1, input register area, address 300001, character length 10, byte order L, which occupies addresses 300001 to 300005</td></tr><tr><td>1!400001.10</td><td>String</td><td>Refers to station 1, hold register area, address 400001, character length 10, byte order L, which occupies addresses 400001 to 400005</td></tr><tr><td>1!400001.10H</td><td>String</td><td>Refers to station 1, hold register area, address 400001, character length 10, byte order H, which occupies addresses 400001 to 400005</td></tr><tr><td>1!400001.10L</td><td>String</td><td>Refers to station 1, hold register area, address 400001, character length 10, byte order L, which occupies addresses 400001 to 400005</td></tr><tr><td>1!400001.10D</td><td>String</td><td>Refers to station 1, hold register area, address 300001, character length 10, byte order D, which occupies addresses 400001 to 400005</td></tr><tr><td>1!400001.10E</td><td>String</td><td>Refers to station 1, hold register area, address 300001, character length 10, byte order E, which occupies addresses 400001 to 400005</td></tr></tbody></table><h2 id="use-case" tabindex="-1">Use Case <a class="header-anchor" href="#use-case" aria-label="Permalink to “Use Case”">​</a></h2><p>This chapter also provides practical examples to facilitate a quick start.</p><ul><li><a href="./example/modbus-slave/modbus-slave.html">Modbus Slave Simulator</a></li><li><a href="./example/dtu/dtu-connection.html">USR DTU</a></li></ul><h2 id="data-monitoring" tabindex="-1">Data Monitoring <a class="header-anchor" href="#data-monitoring" aria-label="Permalink to “Data Monitoring”">​</a></h2><p>After completing the point configuration, you can click <strong>Monitoring</strong> -&gt; <strong>Data Monitoring</strong> to view device information and control devices. For details, refer to <a href="./../../../admin/monitoring.html">Data Monitoring</a>.</p>',46)])])}const b=e(o,[["render",i]]);export{u as __pageData,b as default};
