import{_ as d,c as r,o as a,ah as e}from"./chunks/framework.D2dsaVOY.js";const b=JSON.parse('{"title":"数据类型说明","description":"","frontmatter":{},"headers":[],"relativePath":"zh_CN/appendix/data-type.md","filePath":"zh_CN/appendix/data-type.md"}'),i={name:"zh_CN/appendix/data-type.md"};function l(x,t,n,o,h,s){return a(),r("div",null,[...t[0]||(t[0]=[e('<h1 id="数据类型说明" tabindex="-1">数据类型说明 <a class="header-anchor" href="#数据类型说明" aria-label="Permalink to “数据类型说明”">​</a></h1><p>数据类型是编程语言中非常重要的概念，其作用主要有以下几个方面：</p><ul><li>内存分配：不同的数据类型在内存中需要分配不同的空间。例如，整数通常需要占用 4 个字节的内存空间，而浮点数可能需要 8 个字节或更多的空间。因此，正确的数据类型可以确保内存使用效率和程序性能。</li><li>数据处理：不同的数据类型可以支持不同的操作和运算。例如，整数可以进行加减乘除等算术运算，而字符串可以进行连接、分割等操作。正确的数据类型可以确保数据处理的正确性和有效性。</li><li>输入输出：不同的数据类型需要不同的输入输出方式。例如，整数可以通过标准输入输出进行读写，正确的数据类型可以确保程序能够正确地读写数据。</li><li>代码逻辑：不同的数据类型对应不同的含义和用途，因此在编写代码时需要选择正确的数据类型来反映代码逻辑和意图。例如，布尔型变量通常用于控制流程和逻辑判断，而整数和浮点数通常用于数学计算。</li></ul><p>综上所述，正确选择和使用数据类型是编程中至关重要的一步，它直接关系到程序的正确性、性能和可维护性。<br> 下面是 gridbeat 的数据类型：</p><table tabindex="0"><thead><tr><th>数据类型</th><th>数据范围</th><th>占用字节</th><th>数据示例</th></tr></thead><tbody><tr><td>INT8</td><td>-128～127</td><td>1</td><td>比如 100，就是[0x64]</td></tr><tr><td>UINT8</td><td>0～255</td><td>1</td><td>比如 100，就是[0x64]</td></tr><tr><td>INT16</td><td>-32,768~32,767</td><td>2</td><td>比如 100，就是[0x64][0x00]</td></tr><tr><td>UINT16</td><td>0~65,535</td><td>2</td><td>比如 100，就是[0x64][0x00]</td></tr><tr><td>INT32</td><td>-2,147,483,648~2,147,483,647</td><td>4</td><td>比如 100，就是[0x64][0x00][0x00][0x00]</td></tr><tr><td>UINT32</td><td>0~4,294,967,295</td><td>4</td><td>比如 100，就是[0x64][0x00][0x00][0x00]</td></tr><tr><td>INT64</td><td>-9,223,372,036,854,775,808~9,223,372,036,854,775,807</td><td>8</td><td>比如 100，就是[0x64][0x00][0x00][0x00][0x00][0x00][0x00][0x00]</td></tr><tr><td>UINT64</td><td>0~18,446,744,073,709,551,615</td><td>8</td><td>比如 100，就是[0x64][0x00][0x00][0x00][0x00][0x00][0x00][0x00]</td></tr><tr><td>FLOAT(real)</td><td>-3.40E+38~+3.40E+38</td><td>4</td><td>比如 100，就是[0x00][0x00][0xC8][0x42]</td></tr><tr><td>DOUBLE(long real)</td><td>-1.79E+308~+1.79E+308</td><td>8</td><td>比如 100，就是[0x00][0x00][0x00][0x00][0x00][0x00][0x59][0x40]</td></tr><tr><td>BIT</td><td>0/1</td><td>1 个位</td><td>0x11 的第 0 位，为 1</td></tr><tr><td>BOOL</td><td>True/False</td><td>1 个位</td><td>0x11 的第 0 位，为 True</td></tr><tr><td>WORD</td><td>0~65,535</td><td>2</td><td>比如 100，就是[0x64][0x00]</td></tr><tr><td>DWORD</td><td>0~4,294,967,295</td><td>4</td><td>比如 100，就是[0x64][0x00][0x00][0x00]</td></tr><tr><td>LWORD</td><td>0~18,446,744,073,709,551,615</td><td>8</td><td>比如 100，就是[0x64][0x00][0x00][0x00][0x00][0x00][0x00][0x00]</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>编写程序需要理解数据的本质。例如，int 数据类型下的数字 1065353216 的数据本质是“00 00 80 3F”，而 float 数据类型下的数字 1 的数据本质也是“00 00 80 3F”。然而，当面对数据“00 00 80 3F”时，我们无法确定其代表什么含义。可能会认为 1065353216 太大，显然不对，必然是 float 类型的 1。但这是主观的人为判断，程序并不知道。因此，在解析数据时，必须使用正确的数据类型进行解析，否则会产生乱码。换言之，对于数据来说，应当使用与其原本类型相同的类型进行解析。</p></div><h2 id="关于数据排列问题" tabindex="-1">关于数据排列问题 <a class="header-anchor" href="#关于数据排列问题" aria-label="Permalink to “关于数据排列问题”">​</a></h2><p>上述的数据表格里有例子，int 数据 100 的本质是 &quot;64 00 00 00&quot;，而从我们的人的感官来说，应该是 &quot;00 00 00 64&quot; 比较合理。大部分人的习惯是高位在前，低位在后。但这只是一种规定，数据存储可以有多种排列，大体上分为三种：</p><ul><li>小端排列：典型的代表是 C# 语言，三菱 PLC。</li><li>大端排列：典型的代表是西门子 PLC。</li><li>其他不规则：典型的代表是 modbus 设备。</li></ul><p>gridbeat 支持多种字节顺序，如下表所示：</p><h3 id="endian" tabindex="-1">ENDIAN <a class="header-anchor" href="#endian" aria-label="Permalink to “ENDIAN”">​</a></h3><p>字节顺序，适用于 int16/uint16/int32/uint32/float 数据类型，详细说明见下表。</p><table tabindex="0"><thead><tr><th>符号</th><th>字节顺序</th><th>支持的数据类型</th><th>备注</th></tr></thead><tbody><tr><td>#B</td><td>2,1</td><td>int16/uint16</td><td></td></tr><tr><td>#L</td><td>1,2</td><td>int16/uint16</td><td>默认字节顺序</td></tr><tr><td>#LL</td><td>1,2,3,4</td><td>int32/uint32/float</td><td>默认字节顺序</td></tr><tr><td>#LB</td><td>2,1,4,3</td><td>int32/uint32/float</td><td></td></tr><tr><td>#BB</td><td>3,4,1,2</td><td>int32/uint32/float</td><td></td></tr><tr><td>#BL</td><td>4,3,2,1</td><td>int32/uint32/float</td><td></td></tr></tbody></table><h3 id="len-h-l-d-e" tabindex="-1">.LEN[H][L][D][E] <a class="header-anchor" href="#len-h-l-d-e" aria-label="Permalink to “.LEN[H][L][D][E]”">​</a></h3><p>当数据类型为 STRING 类型时，<strong>.LEN</strong> 是必填项，表示字符串需要占用的字节长度，每个寄存器中包含<strong>H</strong>，<strong>L</strong>，<strong>D</strong> 和<strong>E</strong> 四种存储方式，如下列表格所示。</p><table tabindex="0"><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>H</td><td>一个寄存器存储两个字节，高字节在前低字节在后。</td></tr><tr><td>L</td><td>一个寄存器存储两个字节，低字节在前高字节在后。</td></tr><tr><td>D</td><td>一个寄存器存储一个字节，且存储在低字节。</td></tr><tr><td>E</td><td>一个寄存器存储一个字节，且存储在高字节。</td></tr></tbody></table>',16)])])}const c=d(i,[["render",l]]);export{b as __pageData,c as default};
